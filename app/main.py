from dotenv import load_dotenv
import os
import asyncio
import logging
import random

from aiogram import Bot, Dispatcher, F
from aiogram.filters import CommandStart
from aiogram.types import CallbackQuery, Message, ReplyKeyboardRemove
from aiogram.fsm.state import StatesGroup, State
from aiogram.fsm.context import FSMContext

from app.bd import init_db, Session, User, Meeting, MeetingStatus, reset_meetings
from sqlalchemy import select, or_, and_
from app.keyboards import reg_button, main_buttons, meet_candidate_kb, answer_request_kb
from sqlalchemy.sql import func

logging.basicConfig(level=logging.INFO, format="%(asctime)s  %(levelname)-8s %(name)s | %(message)s")

load_dotenv()

BOT_TOKEN = os.getenv('BOT_TOKEN')
if not BOT_TOKEN:
    raise ValueError('BOT_TOKEN is not set in the environment variables.')

bot = Bot(BOT_TOKEN)
dp = Dispatcher()

class Reg(StatesGroup):
    waiting_registration = State()

@dp.message(F.text == '–ü—Ä–æ—Ñ–∏–ª—å')
async def profile(message: Message) -> None:
    async with Session() as session:
        user = await session.scalar(select(User).where(User.tg_id == message.from_user.id))
    
    if user:
        await message.answer(text=f'–¢–≤–æ–π –ø—Ä–æ—Ñ–∏–ª—å:\n\n*–ò–º—è:* {user.first_name}\n*–§–∞–º–∏–ª–∏—è:* {user.last_name}\n*–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–µ –∏–º—è:* @{user.username or "‚Äî"}\n*ID –≤ Telegram:* {user.tg_id}', parse_mode='Markdown', reply_markup=main_buttons)
    else:
        await message.answer(text='–¢—ã –Ω–µ –∑–∞—Ä–µ–≥–µ—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω! –ù–∞–ø–∏—à–∏ /start, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å.', reply_markup=reg_button)

@dp.message(CommandStart())
async def start_command(message: Message, state: FSMContext) -> None:
    await state.clear()

    async with Session() as session:
        user = await session.scalar(select(User).where(User.tg_id == message.from_user.id))

    if user:
        await message.answer(text=f'–° –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ–º, *{message.from_user.full_name}*!üëã\n–•–æ—á–µ—à—å –≤—Å—Ç—Ä–µ—Ç–∏—Ç—å—Å—è —Å –∫–µ–º-–Ω–∏–±—É–¥—å?.', parse_mode='Markdown', reply_markup=main_buttons)
    else:
        await message.answer(text=f'–ü—Ä–∏–≤–µ—Ç, *{message.from_user.full_name}*!üëã\n–Ø –±–æ—Ç –¥–ª—è —Å–ª—É—á–∞–π–Ω—ã—Ö –≤—Å—Ç—Ä–µ—á. –ó–∞—Ä–µ–≥–µ—Å—Ç—Ä–∏—Ä—É–π—Å—è, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å! ‚òïÔ∏è', parse_mode='Markdown', reply_markup=reg_button)

@dp.message(F.text == '–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è üöÄ')
async def registration(message: Message, state : FSMContext) -> None:
    async with Session() as session:
        is_exists = await session.scalar(select(User).where(User.tg_id == message.from_user.id))
        if is_exists:
            await message.answer(text='–¢—ã —É–∂–µ –∑–∞—Ä–µ–≥–µ—Å—Ç—Ä–∏—Ä–≤–∞–Ω!‚úÖ\n–ù–∞–ø–∏—à–∏ /meet, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å.', parse_mode='Markdown', reply_markup=ReplyKeyboardRemove())
            return
        else:
            await message.answer(text='–î–∞–≤–∞–π –∑–Ω–∞–∫–æ–º–∏—Ç—å—Å—è! üòÄ\n–ù–∞–ø–∏—à–∏ —Å–≤–æ–∏ *–∏–º—è –∏ —Ñ–∞–º–∏–ª–∏—é* –æ–¥–Ω–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º, –Ω–∞–ø—Ä–∏–º–µ—Ä: `–õ–µ–Ω–∞ –ì–æ–ª–æ–≤–∞—á`', parse_mode='Markdown', reply_markup=ReplyKeyboardRemove())
            await state.set_state(Reg.waiting_registration)

@dp.message(Reg.waiting_registration, F.text)
async def save_name(message : Message, state : FSMContext) -> None: 
    splitted = message.text.strip().split()
    if len(splitted) != 2:
        await message.answer(text='–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏ *–∏–º—è –∏ —Ñ–∞–º–∏–ª–∏—é* –æ–¥–Ω–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º, –Ω–∞–ø—Ä–∏–º–µ—Ä: `–õ–µ–Ω–∞ –ì–æ–ª–æ–≤–∞—á`', parse_mode='Markdown')
        return
    
    fname, lname = splitted
    async with Session.begin() as session:
        user = await session.scalar(select(User).where(User.tg_id == message.from_user.id).with_for_update())
        if user:
            await message.answer(text='–¢—ã —É–∂–µ –∑–∞—Ä–µ–≥–µ—Å—Ç—Ä–∏—Ä–≤–∞–Ω!‚úÖ\n–ù–∞–ø–∏—à–∏ /meet, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å.', parse_mode='Markdown', reply_markup=ReplyKeyboardRemove())
            await state.clear()
            return
        
        session.add(User(
            tg_id=message.from_user.id,
            username=message.from_user.username,
            first_name=fname,
            last_name=lname
        ))

        await message.answer(f'–°–ø–∞—Å–∏–±–æ, *{fname}*! –¢—ã c –Ω–∞–º–∏ ‚úÖ\n –ù–∞–∂–º–∏ ¬´–í—Å—Ç—Ä–µ—Ç–∏—Ç—å—Å—è ‚òïÔ∏è¬ª, —á—Ç–æ–±—ã –Ω–∞–π—Ç–∏ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞.', reply_markup=main_buttons, parse_mode='Markdown')
        await state.clear()

async def _available_persons(sess, me_id: int):
    blocked = select(Meeting.user_b_id).where(
        or_(
            and_(Meeting.user_a_id == me_id,
                 Meeting.status.in_([MeetingStatus.pending,
                                     MeetingStatus.confirmed])),
            and_(Meeting.user_b_id == me_id,
                 Meeting.status.in_([MeetingStatus.pending,
                                     MeetingStatus.confirmed]))
        )
    )
    return (await sess.scalars(select(User).where(User.id != me_id, ~User.id.in_(blocked)))).all()

@dp.message(F.text == '–í—Å—Ç—Ä–µ—Ç–∏—Ç—å—Å—è ‚òïÔ∏è')
async def find_person(message : Message) -> None:
    async with Session() as session:
        me: User = await session.scalar(select(User).where(User.tg_id == message.from_user.id))
        candidates = await _available_persons(session, me.id)

    if not candidates:
        await reset_meetings(me.id, session)
        await session.commit()         
        candidates = await _available_persons(session, me.id)
    
    if not candidates:
        await message.answer('–ù–µ—Ç —Å–≤–æ–±–æ–¥–Ω—ã—Ö —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–æ–≤, –ø–æ–ø—Ä–æ–±—É–π –ø–æ–∑–∂–µ ‚òïÔ∏è')
        return

    person = random.choice(candidates)
    await message.answer(f'–ö–∞–∫ –Ω–∞—Å—á—ë—Ç –≤—Å—Ç—Ä–µ—á–∏ —Å *{person.first_name} {person.last_name}*?', parse_mode="Markdown", reply_markup=meet_candidate_kb(person.tg_id))

@dp.callback_query(F.data == 'meet_other')
async def meet_other(callback: CallbackQuery):
    await callback.message.delete()
    await find_person(callback.message)

@dp.callback_query(F.data.startswith('meet_request:'))
async def meet_request(callback: CallbackQuery):
    initiator_tg = callback.from_user.id
    person_tg = int(callback.data.split(':')[1])

    async with Session.begin() as session:
        initiator = await session.scalar(select(User).where(User.tg_id == initiator_tg))
        person = await session.scalar(select(User).where(User.tg_id == person_tg))

        stmt = select(Meeting).where(
            or_(
                and_(Meeting.user_a_id == initiator.id, Meeting.user_b_id == person.id),
                and_(Meeting.user_a_id == person.id, Meeting.user_b_id == initiator.id)
            )
        )
        meet: Meeting | None = await session.scalar(stmt)
        if meet and meet.status == MeetingStatus.pending:
            await callback.answer("–ó–∞–ø—Ä–æ—Å —É–∂–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω üíå", show_alert=True)
            return
        if meet and meet.status in {MeetingStatus.declined, MeetingStatus.archived}:
            meet.status = MeetingStatus.pending
            meet.user_a_id, meet.user_b_id = initiator.id, person.id
            meet.created_at = func.now()
        if not meet:
            meet = Meeting(user_a_id=initiator.id, user_b_id=person.id, status=MeetingStatus.pending)
            session.add(meet)
        await session.flush() 

    await callback.message.edit_text(f'–ó–∞–ø—Ä–æ—Å –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω *{person.first_name}* ‚úÖ\n–û–∂–∏–¥–∞–µ–º –æ—Ç–≤–µ—Ç‚Ä¶', reply_markup=None, parse_mode='Markdown')

    await bot.send_message(person_tg, f'*{initiator.first_name} {initiator.last_name}* —Ö–æ—á–µ—Ç –≤—Å—Ç—Ä–µ—Ç–∏—Ç—å—Å—è —Å –≤–∞–º–∏. üòÄ', parse_mode='Markdown', reply_markup=answer_request_kb(meet.id))

@dp.callback_query(F.data.startswith(("meet_accept:", "meet_decline:")))
async def meet_response(callback: CallbackQuery):
    action, meet_id_txt = callback.data.split(":")
    meet_id = int(meet_id_txt)

    async with Session.begin() as session:
        stmt = (
            select(Meeting)
            .where(Meeting.id == meet_id)
            .with_for_update()
        )
        meet: Meeting | None = await session.scalar(stmt)

        if not meet or meet.status != MeetingStatus.pending:
            await callback.answer("–ó–∞—è–≤–∫–∞ —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–∞", show_alert=True)
            return

        initiator = await session.get(User, meet.user_a_id)
        partner   = await session.get(User, meet.user_b_id)

        if action == "meet_accept":
            meet.status = MeetingStatus.confirmed
            await session.flush()     

            await bot.send_message(
                initiator.tg_id,
                f"üéâ *{partner.first_name}* —Å–æ–≥–ª–∞—Å–∏–ª—Å—è!\n"
                f"–°–≤—è–∂–∏—Ç–µ—Å—å –≤ Telegram:\n"
                f"‚Ä¢ @{initiator.username or '‚Äî'}\n"
                f"‚Ä¢ @{partner.username   or '‚Äî'}",
                parse_mode="Markdown",
            )
            await callback.message.edit_text(
                "–í—ã –ø–æ–¥—Ç–≤–µ—Ä–¥–∏–ª–∏ –≤—Å—Ç—Ä–µ—á—É!\n"
                "–î–∞–Ω–Ω—ã–µ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –æ–±–µ–∏–º —Å—Ç–æ—Ä–æ–Ω–∞–º.",
                reply_markup=None,
            )
        else:
            meet.status = MeetingStatus.declined
            await session.flush()

            await bot.send_message(
                initiator.tg_id,
                f"üòî *{partner.first_name}* –æ—Ç–∫–∞–∑–∞–ª—Å—è –æ—Ç –≤—Å—Ç—Ä–µ—á–∏.\n"
                "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –≤—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥–æ–≥–æ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞.",
            )
            await callback.message.edit_text(
                "–í—ã –æ—Ç–∫–ª–æ–Ω–∏–ª–∏ –∑–∞–ø—Ä–æ—Å.\n"
                "–ú–æ–∂–Ω–æ –Ω–∞–∂–∞—Ç—å ¬´–í—Å—Ç—Ä–µ—Ç–∏—Ç—å—Å—è¬ª –∏ –≤—ã–±—Ä–∞—Ç—å –Ω–æ–≤–æ–≥–æ —á–µ–ª–æ–≤–µ–∫–∞.",
                reply_markup=None,
            )

@dp.message(F.text)
async def fallback(message: Message):
    await message.answer("–ù–∞–±–µ—Ä–∏ /start –∏–ª–∏ –Ω–∞–∂–º–∏ ¬´–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è¬ª üôÇ")

async def main() -> None:
    await init_db()
    await dp.start_polling(bot)

if __name__ == '__main__':
    asyncio.run(main())